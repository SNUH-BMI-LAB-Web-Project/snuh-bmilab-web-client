/* tslint:disable */
/* eslint-disable */
/**
 * BMI-LAB Web API
 * BMI-LAB을 관리하기 위한 웹 서비스
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AcademicPresentationFindAllResponse,
  AcademicPresentationResponse,
  AuthorFindAllResponse,
  AuthorResponse,
  AwardFindAllResponse,
  AwardResponse,
  CreateAcademicPresentationRequest,
  CreateAuthorRequest,
  CreateAwardRequest,
  CreateJournalRequest,
  CreatePaperRequest,
  CreatePatentRequest,
  ErrorResponse,
  JournalFindAllResponse,
  JournalResponse,
  PaperFindAllResponse,
  PaperResponse,
  PatentFindAllResponse,
  PatentResponse,
  UpdateAcademicPresentationRequest,
  UpdateAuthorRequest,
  UpdateAwardRequest,
  UpdateJournalRequest,
  UpdatePaperRequest,
  UpdatePatentRequest,
} from '../models/index';
import {
    AcademicPresentationFindAllResponseFromJSON,
    AcademicPresentationFindAllResponseToJSON,
    AcademicPresentationResponseFromJSON,
    AcademicPresentationResponseToJSON,
    AuthorFindAllResponseFromJSON,
    AuthorFindAllResponseToJSON,
    AuthorResponseFromJSON,
    AuthorResponseToJSON,
    AwardFindAllResponseFromJSON,
    AwardFindAllResponseToJSON,
    AwardResponseFromJSON,
    AwardResponseToJSON,
    CreateAcademicPresentationRequestFromJSON,
    CreateAcademicPresentationRequestToJSON,
    CreateAuthorRequestFromJSON,
    CreateAuthorRequestToJSON,
    CreateAwardRequestFromJSON,
    CreateAwardRequestToJSON,
    CreateJournalRequestFromJSON,
    CreateJournalRequestToJSON,
    CreatePaperRequestFromJSON,
    CreatePaperRequestToJSON,
    CreatePatentRequestFromJSON,
    CreatePatentRequestToJSON,
    ErrorResponseFromJSON,
    ErrorResponseToJSON,
    JournalFindAllResponseFromJSON,
    JournalFindAllResponseToJSON,
    JournalResponseFromJSON,
    JournalResponseToJSON,
    PaperFindAllResponseFromJSON,
    PaperFindAllResponseToJSON,
    PaperResponseFromJSON,
    PaperResponseToJSON,
    PatentFindAllResponseFromJSON,
    PatentFindAllResponseToJSON,
    PatentResponseFromJSON,
    PatentResponseToJSON,
    UpdateAcademicPresentationRequestFromJSON,
    UpdateAcademicPresentationRequestToJSON,
    UpdateAuthorRequestFromJSON,
    UpdateAuthorRequestToJSON,
    UpdateAwardRequestFromJSON,
    UpdateAwardRequestToJSON,
    UpdateJournalRequestFromJSON,
    UpdateJournalRequestToJSON,
    UpdatePaperRequestFromJSON,
    UpdatePaperRequestToJSON,
    UpdatePatentRequestFromJSON,
    UpdatePatentRequestToJSON,
} from '../models/index';

export interface CreateAcademicPresentationOperationRequest {
    createAcademicPresentationRequest: CreateAcademicPresentationRequest;
}

export interface CreateAwardOperationRequest {
    createAwardRequest: CreateAwardRequest;
}

export interface CreateJournalOperationRequest {
    createJournalRequest: CreateJournalRequest;
}

export interface CreatePaperOperationRequest {
    createPaperRequest: CreatePaperRequest;
}

export interface CreatePatentOperationRequest {
    createPatentRequest: CreatePatentRequest;
}

export interface CreatePublicationRequest {
    createAuthorRequest: CreateAuthorRequest;
}

export interface DeleteAcademicPresentationRequest {
    academicPresentationId: number;
}

export interface DeleteAwardRequest {
    awardId: number;
}

export interface DeleteJournalRequest {
    journalId: number;
}

export interface DeletePaperRequest {
    paperId: number;
}

export interface DeletePatentRequest {
    patentId: number;
}

export interface DeletePublicationRequest {
    authorId: number;
}

export interface GetAcademicPresentationRequest {
    academicPresentationId: number;
}

export interface GetAcademicPresentationsRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface GetAwardRequest {
    awardId: number;
}

export interface GetAwardsRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface GetJournalRequest {
    journalId: number;
}

export interface GetJournalsRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface GetPaperRequest {
    paperId: number;
}

export interface GetPapersRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface GetPatent1Request {
    patentId: number;
}

export interface GetPatentsRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface GetPublication1Request {
    authorId: number;
}

export interface GetPublicationsRequest {
    keyword?: string;
    page?: any;
    size?: any;
    sort?: Array<any>;
}

export interface UpdateAcademicPresentationOperationRequest {
    academicPresentationId: number;
    updateAcademicPresentationRequest: UpdateAcademicPresentationRequest;
}

export interface UpdateAwardOperationRequest {
    awardId: number;
    updateAwardRequest: UpdateAwardRequest;
}

export interface UpdateJournalOperationRequest {
    journalId: number;
    updateJournalRequest: UpdateJournalRequest;
}

export interface UpdatePaperOperationRequest {
    paperId: number;
    updatePaperRequest: UpdatePaperRequest;
}

export interface UpdatePatentOperationRequest {
    patentId: number;
    updatePatentRequest: UpdatePatentRequest;
}

export interface UpdatePublicationRequest {
    authorId: number;
    updateAuthorRequest: UpdateAuthorRequest;
}

/**
 * 
 */
export class ResearchApi extends runtime.BaseAPI {

    /**
     * 새로운 학회발표를 생성하는 POST API
     * 학회발표 생성
     */
    async createAcademicPresentationRaw(requestParameters: CreateAcademicPresentationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AcademicPresentationResponse>> {
        if (requestParameters['createAcademicPresentationRequest'] == null) {
            throw new runtime.RequiredError(
                'createAcademicPresentationRequest',
                'Required parameter "createAcademicPresentationRequest" was null or undefined when calling createAcademicPresentation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAcademicPresentationRequestToJSON(requestParameters['createAcademicPresentationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AcademicPresentationResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 학회발표를 생성하는 POST API
     * 학회발표 생성
     */
    async createAcademicPresentation(requestParameters: CreateAcademicPresentationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AcademicPresentationResponse> {
        const response = await this.createAcademicPresentationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 수상을 생성하는 POST API
     * 수상 생성
     */
    async createAwardRaw(requestParameters: CreateAwardOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AwardResponse>> {
        if (requestParameters['createAwardRequest'] == null) {
            throw new runtime.RequiredError(
                'createAwardRequest',
                'Required parameter "createAwardRequest" was null or undefined when calling createAward().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAwardRequestToJSON(requestParameters['createAwardRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AwardResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 수상을 생성하는 POST API
     * 수상 생성
     */
    async createAward(requestParameters: CreateAwardOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AwardResponse> {
        const response = await this.createAwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 저널을 생성하는 POST API
     * 저널 생성
     */
    async createJournalRaw(requestParameters: CreateJournalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JournalResponse>> {
        if (requestParameters['createJournalRequest'] == null) {
            throw new runtime.RequiredError(
                'createJournalRequest',
                'Required parameter "createJournalRequest" was null or undefined when calling createJournal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/journals`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateJournalRequestToJSON(requestParameters['createJournalRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JournalResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 저널을 생성하는 POST API
     * 저널 생성
     */
    async createJournal(requestParameters: CreateJournalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JournalResponse> {
        const response = await this.createJournalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 논문을 생성하는 POST API
     * 논문 생성
     */
    async createPaperRaw(requestParameters: CreatePaperOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperResponse>> {
        if (requestParameters['createPaperRequest'] == null) {
            throw new runtime.RequiredError(
                'createPaperRequest',
                'Required parameter "createPaperRequest" was null or undefined when calling createPaper().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePaperRequestToJSON(requestParameters['createPaperRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 논문을 생성하는 POST API
     * 논문 생성
     */
    async createPaper(requestParameters: CreatePaperOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperResponse> {
        const response = await this.createPaperRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 특허를 생성하는 POST API
     * 특허 생성
     */
    async createPatentRaw(requestParameters: CreatePatentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PatentResponse>> {
        if (requestParameters['createPatentRequest'] == null) {
            throw new runtime.RequiredError(
                'createPatentRequest',
                'Required parameter "createPatentRequest" was null or undefined when calling createPatent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreatePatentRequestToJSON(requestParameters['createPatentRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PatentResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 특허를 생성하는 POST API
     * 특허 생성
     */
    async createPatent(requestParameters: CreatePatentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PatentResponse> {
        const response = await this.createPatentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 새로운 저서를 생성하는 POST API
     * 저서 생성
     */
    async createPublicationRaw(requestParameters: CreatePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorResponse>> {
        if (requestParameters['createAuthorRequest'] == null) {
            throw new runtime.RequiredError(
                'createAuthorRequest',
                'Required parameter "createAuthorRequest" was null or undefined when calling createPublication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateAuthorRequestToJSON(requestParameters['createAuthorRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorResponseFromJSON(jsonValue));
    }

    /**
     * 새로운 저서를 생성하는 POST API
     * 저서 생성
     */
    async createPublication(requestParameters: CreatePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorResponse> {
        const response = await this.createPublicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 학회발표를 삭제하는 DELETE API (관리자 전용)
     * 학회발표 삭제
     */
    async deleteAcademicPresentationRaw(requestParameters: DeleteAcademicPresentationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['academicPresentationId'] == null) {
            throw new runtime.RequiredError(
                'academicPresentationId',
                'Required parameter "academicPresentationId" was null or undefined when calling deleteAcademicPresentation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations/{academicPresentationId}`.replace(`{${"academicPresentationId"}}`, encodeURIComponent(String(requestParameters['academicPresentationId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 학회발표를 삭제하는 DELETE API (관리자 전용)
     * 학회발표 삭제
     */
    async deleteAcademicPresentation(requestParameters: DeleteAcademicPresentationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAcademicPresentationRaw(requestParameters, initOverrides);
    }

    /**
     * 수상을 삭제하는 DELETE API (관리자 전용)
     * 수상 삭제
     */
    async deleteAwardRaw(requestParameters: DeleteAwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['awardId'] == null) {
            throw new runtime.RequiredError(
                'awardId',
                'Required parameter "awardId" was null or undefined when calling deleteAward().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards/{awardId}`.replace(`{${"awardId"}}`, encodeURIComponent(String(requestParameters['awardId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 수상을 삭제하는 DELETE API (관리자 전용)
     * 수상 삭제
     */
    async deleteAward(requestParameters: DeleteAwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAwardRaw(requestParameters, initOverrides);
    }

    /**
     * 저널을 삭제하는 DELETE API (관리자 전용)
     * 저널 삭제
     */
    async deleteJournalRaw(requestParameters: DeleteJournalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['journalId'] == null) {
            throw new runtime.RequiredError(
                'journalId',
                'Required parameter "journalId" was null or undefined when calling deleteJournal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/journals/{journalId}`.replace(`{${"journalId"}}`, encodeURIComponent(String(requestParameters['journalId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 저널을 삭제하는 DELETE API (관리자 전용)
     * 저널 삭제
     */
    async deleteJournal(requestParameters: DeleteJournalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteJournalRaw(requestParameters, initOverrides);
    }

    /**
     * 논문을 삭제하는 DELETE API (관리자 전용)
     * 논문 삭제
     */
    async deletePaperRaw(requestParameters: DeletePaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling deletePaper().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers/{paperId}`.replace(`{${"paperId"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 논문을 삭제하는 DELETE API (관리자 전용)
     * 논문 삭제
     */
    async deletePaper(requestParameters: DeletePaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePaperRaw(requestParameters, initOverrides);
    }

    /**
     * 특허를 삭제하는 DELETE API (관리자 전용)
     * 특허 삭제
     */
    async deletePatentRaw(requestParameters: DeletePatentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['patentId'] == null) {
            throw new runtime.RequiredError(
                'patentId',
                'Required parameter "patentId" was null or undefined when calling deletePatent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents/{patentId}`.replace(`{${"patentId"}}`, encodeURIComponent(String(requestParameters['patentId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 특허를 삭제하는 DELETE API (관리자 전용)
     * 특허 삭제
     */
    async deletePatent(requestParameters: DeletePatentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePatentRaw(requestParameters, initOverrides);
    }

    /**
     * 저서를 삭제하는 DELETE API (관리자 전용)
     * 저서 삭제
     */
    async deletePublicationRaw(requestParameters: DeletePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['authorId'] == null) {
            throw new runtime.RequiredError(
                'authorId',
                'Required parameter "authorId" was null or undefined when calling deletePublication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors/{authorId}`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters['authorId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 저서를 삭제하는 DELETE API (관리자 전용)
     * 저서 삭제
     */
    async deletePublication(requestParameters: DeletePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePublicationRaw(requestParameters, initOverrides);
    }

    /**
     * 모든 학회발표 데이터를 Excel 파일로 다운로드합니다.
     * 학회발표 Excel 다운로드
     */
    async downloadAcademicPresentationsExcelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations/excel`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 모든 학회발표 데이터를 Excel 파일로 다운로드합니다.
     * 학회발표 Excel 다운로드
     */
    async downloadAcademicPresentationsExcel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadAcademicPresentationsExcelRaw(initOverrides);
        return await response.value();
    }

    /**
     * 모든 수상 데이터를 Excel 파일로 다운로드합니다.
     * 수상 Excel 다운로드
     */
    async downloadAwardsExcelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards/excel`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 모든 수상 데이터를 Excel 파일로 다운로드합니다.
     * 수상 Excel 다운로드
     */
    async downloadAwardsExcel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadAwardsExcelRaw(initOverrides);
        return await response.value();
    }

    /**
     * 모든 논문 데이터를 Excel 파일로 다운로드합니다.
     * 논문 Excel 다운로드
     */
    async downloadPapersExcelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers/excel`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 모든 논문 데이터를 Excel 파일로 다운로드합니다.
     * 논문 Excel 다운로드
     */
    async downloadPapersExcel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadPapersExcelRaw(initOverrides);
        return await response.value();
    }

    /**
     * 모든 특허 데이터를 Excel 파일로 다운로드합니다.
     * 특허 Excel 다운로드
     */
    async downloadPatentsExcelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents/excel`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 모든 특허 데이터를 Excel 파일로 다운로드합니다.
     * 특허 Excel 다운로드
     */
    async downloadPatentsExcel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadPatentsExcelRaw(initOverrides);
        return await response.value();
    }

    /**
     * 모든 저서 데이터를 Excel 파일로 다운로드합니다.
     * 저서 Excel 다운로드
     */
    async downloadPublicationsExcelRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors/excel`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 모든 저서 데이터를 Excel 파일로 다운로드합니다.
     * 저서 Excel 다운로드
     */
    async downloadPublicationsExcel(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.downloadPublicationsExcelRaw(initOverrides);
        return await response.value();
    }

    /**
     * 학회발표 ID로 학회발표를 상세 조회하는 GET API
     * 학회발표 단건 조회
     */
    async getAcademicPresentationRaw(requestParameters: GetAcademicPresentationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AcademicPresentationResponse>> {
        if (requestParameters['academicPresentationId'] == null) {
            throw new runtime.RequiredError(
                'academicPresentationId',
                'Required parameter "academicPresentationId" was null or undefined when calling getAcademicPresentation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations/{academicPresentationId}`.replace(`{${"academicPresentationId"}}`, encodeURIComponent(String(requestParameters['academicPresentationId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AcademicPresentationResponseFromJSON(jsonValue));
    }

    /**
     * 학회발표 ID로 학회발표를 상세 조회하는 GET API
     * 학회발표 단건 조회
     */
    async getAcademicPresentation(requestParameters: GetAcademicPresentationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AcademicPresentationResponse> {
        const response = await this.getAcademicPresentationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어와 함께 학회발표 목록을 조회하는 GET API
     * 학회발표 목록 조회
     */
    async getAcademicPresentationsRaw(requestParameters: GetAcademicPresentationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AcademicPresentationFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AcademicPresentationFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어와 함께 학회발표 목록을 조회하는 GET API
     * 학회발표 목록 조회
     */
    async getAcademicPresentations(requestParameters: GetAcademicPresentationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AcademicPresentationFindAllResponse> {
        const response = await this.getAcademicPresentationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 수상 ID로 수상을 상세 조회하는 GET API
     * 수상 단건 조회
     */
    async getAwardRaw(requestParameters: GetAwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AwardResponse>> {
        if (requestParameters['awardId'] == null) {
            throw new runtime.RequiredError(
                'awardId',
                'Required parameter "awardId" was null or undefined when calling getAward().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards/{awardId}`.replace(`{${"awardId"}}`, encodeURIComponent(String(requestParameters['awardId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AwardResponseFromJSON(jsonValue));
    }

    /**
     * 수상 ID로 수상을 상세 조회하는 GET API
     * 수상 단건 조회
     */
    async getAward(requestParameters: GetAwardRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AwardResponse> {
        const response = await this.getAwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어와 함께 수상 목록을 조회하는 GET API
     * 수상 목록 조회
     */
    async getAwardsRaw(requestParameters: GetAwardsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AwardFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AwardFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어와 함께 수상 목록을 조회하는 GET API
     * 수상 목록 조회
     */
    async getAwards(requestParameters: GetAwardsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AwardFindAllResponse> {
        const response = await this.getAwardsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 저널 ID로 저널을 상세 조회하는 GET API
     * 저널 단건 조회
     */
    async getJournalRaw(requestParameters: GetJournalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JournalResponse>> {
        if (requestParameters['journalId'] == null) {
            throw new runtime.RequiredError(
                'journalId',
                'Required parameter "journalId" was null or undefined when calling getJournal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/journals/{journalId}`.replace(`{${"journalId"}}`, encodeURIComponent(String(requestParameters['journalId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JournalResponseFromJSON(jsonValue));
    }

    /**
     * 저널 ID로 저널을 상세 조회하는 GET API
     * 저널 단건 조회
     */
    async getJournal(requestParameters: GetJournalRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JournalResponse> {
        const response = await this.getJournalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어(저널명, 출판사, ISSN)와 함께 저널 목록을 조회하는 GET API
     * 저널 목록 조회
     */
    async getJournalsRaw(requestParameters: GetJournalsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JournalFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/journals`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JournalFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어(저널명, 출판사, ISSN)와 함께 저널 목록을 조회하는 GET API
     * 저널 목록 조회
     */
    async getJournals(requestParameters: GetJournalsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JournalFindAllResponse> {
        const response = await this.getJournalsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 논문 ID로 논문을 상세 조회하는 GET API
     * 논문 단건 조회
     */
    async getPaperRaw(requestParameters: GetPaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperResponse>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling getPaper().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers/{paperId}`.replace(`{${"paperId"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperResponseFromJSON(jsonValue));
    }

    /**
     * 논문 ID로 논문을 상세 조회하는 GET API
     * 논문 단건 조회
     */
    async getPaper(requestParameters: GetPaperRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperResponse> {
        const response = await this.getPaperRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어와 함께 논문 목록을 조회하는 GET API
     * 논문 목록 조회
     */
    async getPapersRaw(requestParameters: GetPapersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어와 함께 논문 목록을 조회하는 GET API
     * 논문 목록 조회
     */
    async getPapers(requestParameters: GetPapersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperFindAllResponse> {
        const response = await this.getPapersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 특허 ID로 특허를 상세 조회하는 GET API
     * 특허 단건 조회
     */
    async getPatent1Raw(requestParameters: GetPatent1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PatentResponse>> {
        if (requestParameters['patentId'] == null) {
            throw new runtime.RequiredError(
                'patentId',
                'Required parameter "patentId" was null or undefined when calling getPatent1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents/{patentId}`.replace(`{${"patentId"}}`, encodeURIComponent(String(requestParameters['patentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PatentResponseFromJSON(jsonValue));
    }

    /**
     * 특허 ID로 특허를 상세 조회하는 GET API
     * 특허 단건 조회
     */
    async getPatent1(requestParameters: GetPatent1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PatentResponse> {
        const response = await this.getPatent1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어와 함께 특허 목록을 조회하는 GET API
     * 특허 목록 조회
     */
    async getPatentsRaw(requestParameters: GetPatentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PatentFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PatentFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어와 함께 특허 목록을 조회하는 GET API
     * 특허 목록 조회
     */
    async getPatents(requestParameters: GetPatentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PatentFindAllResponse> {
        const response = await this.getPatentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 저서 ID로 저서를 상세 조회하는 GET API
     * 저서 단건 조회
     */
    async getPublication1Raw(requestParameters: GetPublication1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorResponse>> {
        if (requestParameters['authorId'] == null) {
            throw new runtime.RequiredError(
                'authorId',
                'Required parameter "authorId" was null or undefined when calling getPublication1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors/{authorId}`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters['authorId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorResponseFromJSON(jsonValue));
    }

    /**
     * 저서 ID로 저서를 상세 조회하는 GET API
     * 저서 단건 조회
     */
    async getPublication1(requestParameters: GetPublication1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorResponse> {
        const response = await this.getPublication1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 검색어와 함께 저서 목록을 조회하는 GET API
     * 저서 목록 조회
     */
    async getPublicationsRaw(requestParameters: GetPublicationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorFindAllResponse>> {
        const queryParameters: any = {};

        if (requestParameters['keyword'] != null) {
            queryParameters['keyword'] = requestParameters['keyword'];
        }

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorFindAllResponseFromJSON(jsonValue));
    }

    /**
     * 검색어와 함께 저서 목록을 조회하는 GET API
     * 저서 목록 조회
     */
    async getPublications(requestParameters: GetPublicationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorFindAllResponse> {
        const response = await this.getPublicationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 학회발표를 수정하는 PUT API
     * 학회발표 수정
     */
    async updateAcademicPresentationRaw(requestParameters: UpdateAcademicPresentationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AcademicPresentationResponse>> {
        if (requestParameters['academicPresentationId'] == null) {
            throw new runtime.RequiredError(
                'academicPresentationId',
                'Required parameter "academicPresentationId" was null or undefined when calling updateAcademicPresentation().'
            );
        }

        if (requestParameters['updateAcademicPresentationRequest'] == null) {
            throw new runtime.RequiredError(
                'updateAcademicPresentationRequest',
                'Required parameter "updateAcademicPresentationRequest" was null or undefined when calling updateAcademicPresentation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/academic-presentations/{academicPresentationId}`.replace(`{${"academicPresentationId"}}`, encodeURIComponent(String(requestParameters['academicPresentationId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAcademicPresentationRequestToJSON(requestParameters['updateAcademicPresentationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AcademicPresentationResponseFromJSON(jsonValue));
    }

    /**
     * 학회발표를 수정하는 PUT API
     * 학회발표 수정
     */
    async updateAcademicPresentation(requestParameters: UpdateAcademicPresentationOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AcademicPresentationResponse> {
        const response = await this.updateAcademicPresentationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 수상을 수정하는 PUT API
     * 수상 수정
     */
    async updateAwardRaw(requestParameters: UpdateAwardOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AwardResponse>> {
        if (requestParameters['awardId'] == null) {
            throw new runtime.RequiredError(
                'awardId',
                'Required parameter "awardId" was null or undefined when calling updateAward().'
            );
        }

        if (requestParameters['updateAwardRequest'] == null) {
            throw new runtime.RequiredError(
                'updateAwardRequest',
                'Required parameter "updateAwardRequest" was null or undefined when calling updateAward().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/awards/{awardId}`.replace(`{${"awardId"}}`, encodeURIComponent(String(requestParameters['awardId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAwardRequestToJSON(requestParameters['updateAwardRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AwardResponseFromJSON(jsonValue));
    }

    /**
     * 수상을 수정하는 PUT API
     * 수상 수정
     */
    async updateAward(requestParameters: UpdateAwardOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AwardResponse> {
        const response = await this.updateAwardRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 저널을 수정하는 PUT API
     * 저널 수정
     */
    async updateJournalRaw(requestParameters: UpdateJournalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JournalResponse>> {
        if (requestParameters['journalId'] == null) {
            throw new runtime.RequiredError(
                'journalId',
                'Required parameter "journalId" was null or undefined when calling updateJournal().'
            );
        }

        if (requestParameters['updateJournalRequest'] == null) {
            throw new runtime.RequiredError(
                'updateJournalRequest',
                'Required parameter "updateJournalRequest" was null or undefined when calling updateJournal().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/journals/{journalId}`.replace(`{${"journalId"}}`, encodeURIComponent(String(requestParameters['journalId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateJournalRequestToJSON(requestParameters['updateJournalRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => JournalResponseFromJSON(jsonValue));
    }

    /**
     * 저널을 수정하는 PUT API
     * 저널 수정
     */
    async updateJournal(requestParameters: UpdateJournalOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JournalResponse> {
        const response = await this.updateJournalRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 논문을 수정하는 PUT API
     * 논문 수정
     */
    async updatePaperRaw(requestParameters: UpdatePaperOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaperResponse>> {
        if (requestParameters['paperId'] == null) {
            throw new runtime.RequiredError(
                'paperId',
                'Required parameter "paperId" was null or undefined when calling updatePaper().'
            );
        }

        if (requestParameters['updatePaperRequest'] == null) {
            throw new runtime.RequiredError(
                'updatePaperRequest',
                'Required parameter "updatePaperRequest" was null or undefined when calling updatePaper().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/papers/{paperId}`.replace(`{${"paperId"}}`, encodeURIComponent(String(requestParameters['paperId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePaperRequestToJSON(requestParameters['updatePaperRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaperResponseFromJSON(jsonValue));
    }

    /**
     * 논문을 수정하는 PUT API
     * 논문 수정
     */
    async updatePaper(requestParameters: UpdatePaperOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaperResponse> {
        const response = await this.updatePaperRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 특허를 수정하는 PUT API
     * 특허 수정
     */
    async updatePatentRaw(requestParameters: UpdatePatentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PatentResponse>> {
        if (requestParameters['patentId'] == null) {
            throw new runtime.RequiredError(
                'patentId',
                'Required parameter "patentId" was null or undefined when calling updatePatent().'
            );
        }

        if (requestParameters['updatePatentRequest'] == null) {
            throw new runtime.RequiredError(
                'updatePatentRequest',
                'Required parameter "updatePatentRequest" was null or undefined when calling updatePatent().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/patents/{patentId}`.replace(`{${"patentId"}}`, encodeURIComponent(String(requestParameters['patentId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdatePatentRequestToJSON(requestParameters['updatePatentRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PatentResponseFromJSON(jsonValue));
    }

    /**
     * 특허를 수정하는 PUT API
     * 특허 수정
     */
    async updatePatent(requestParameters: UpdatePatentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PatentResponse> {
        const response = await this.updatePatentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 저서를 수정하는 PUT API
     * 저서 수정
     */
    async updatePublicationRaw(requestParameters: UpdatePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthorResponse>> {
        if (requestParameters['authorId'] == null) {
            throw new runtime.RequiredError(
                'authorId',
                'Required parameter "authorId" was null or undefined when calling updatePublication().'
            );
        }

        if (requestParameters['updateAuthorRequest'] == null) {
            throw new runtime.RequiredError(
                'updateAuthorRequest',
                'Required parameter "updateAuthorRequest" was null or undefined when calling updatePublication().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("JWT", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/research/authors/{authorId}`.replace(`{${"authorId"}}`, encodeURIComponent(String(requestParameters['authorId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAuthorRequestToJSON(requestParameters['updateAuthorRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthorResponseFromJSON(jsonValue));
    }

    /**
     * 저서를 수정하는 PUT API
     * 저서 수정
     */
    async updatePublication(requestParameters: UpdatePublicationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthorResponse> {
        const response = await this.updatePublicationRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
